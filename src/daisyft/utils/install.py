from pathlib import Path
import inspect
from typing import Type
import logging
from ..registry.base import RegistryBase
from ..utils.config import ProjectConfig

def get_component_docs(meta, docstring: str) -> tuple[str, str]:
    """Split documentation into detailed docs and brief class docstring"""
    # Split on the marker
    parts = docstring.split("\n    ---\n")
    brief_doc = parts[0].strip()
    
    # Detailed documentation for the file header
    if len(parts) > 1:
        detailed_doc = parts[1].strip()
    else:
        detailed_doc = docstring
        
    detailed_docs = f'''"""Button Component
{meta.description}
Generated by DaisyFT

{detailed_doc}
"""'''
    
    return detailed_docs, brief_doc

def install_component(
    component_class: Type[RegistryBase], 
    config: ProjectConfig,
    verbose: bool = True
) -> None:
    """Install a component into the user's project
    
    Args:
        component_class: The component class to install
        config: Project configuration
        verbose: Whether to include detailed documentation (default: True)
    """
    meta = component_class._registry_meta
    target_dir = Path(component_class.get_install_path(config))
    target_dir.mkdir(parents=True, exist_ok=True)

    # Get the source code and docstring
    source = inspect.getsource(component_class)
    docstring = inspect.getdoc(component_class) if component_class.__doc__ else ""
    
    # Split documentation
    detailed_docs, brief_doc = get_component_docs(meta, docstring)
    
    # Process source lines to remove Registry decorators and base class
    lines = []
    in_class = False
    class_content = []
    
    for line in source.split('\n'):
        # Skip registry decorator and imports we don't need
        if any(x in line for x in ['@Registry', 'from ..base', 'from ..decorators', 'from daisyft']):
            continue
            
        # Start collecting when we hit the class definition
        if line.startswith('class '):
            in_class = True
            # Remove RegistryBase from class definition
            line = line.replace('(RegistryBase)', '')
            class_content.append(line)
            continue
            
        if in_class:
            # Add the line to class content
            class_content.append(line)
    
    # Generate clean source
    header = detailed_docs if verbose else f'"""Button Component\n{meta.description}\nGenerated by DaisyFT\n"""'
    
    clean_source = f'''{header}

{chr(10).join(meta.imports)}

@dataclass
class {meta.name.capitalize()}:
    """{brief_doc}"""
    {chr(10).join(class_content[1:])}'''

    # Write the file
    target_path = target_dir / f"{meta.name}.py"
    target_path.write_text(clean_source)    
