from pathlib import Path
import inspect
from typing import Type
from ..registry.base import RegistryBase
from ..utils.config import ProjectConfig

def install_component(component_class: Type[RegistryBase], config: ProjectConfig) -> None:
    """Install a component into the user's project"""
    meta = component_class._registry_meta
    target_dir = Path(component_class.get_install_path(config))  # Ensure Path object
    target_dir.mkdir(parents=True, exist_ok=True)

    # Get the source code
    source = inspect.getsource(component_class)
    
    # Clean up the source code
    lines = []
    in_class = False
    docstring = None
    
    # Extract docstring separately
    if component_class.__doc__:
        docstring = inspect.cleandoc(component_class.__doc__)
    
    # Process source lines
    for line in source.split('\n'):
        # Skip registry decorator and base class
        if any(x in line for x in ['@Registry', '(RegistryBase)']):
            continue
            
        # Start collecting when we hit the class definition
        if line.startswith('class '):
            in_class = True
            # Remove RegistryBase from class definition
            line = line.replace('(RegistryBase)', '')
            lines.append(line)
            continue
            
        if in_class:
            lines.append(line)
    
    # Generate clean source with imports and docstring
    clean_source = f'''"""Button Component
{meta.description}
Generated by DaisyFT
"""

{chr(10).join(meta.imports)}

@dataclass
class {meta.name.capitalize()}:
    """{docstring}"""
{chr(10).join(lines[1:])}
'''
    
    # Write the file
    target_path = target_dir / f"{meta.name}.py"
    target_path.write_text(clean_source)
